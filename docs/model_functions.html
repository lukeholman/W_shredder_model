<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />




<title>Functions used to run the model</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/flatly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>




<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->




</head>

<body>


<div class="container-fluid main-container">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">W-shredder</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="about.html">About</a>
</li>
<li>
  <a href="license.html">License</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/lukeholman/W_shredder_model">
    <span class="fa fa-github"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<!-- Add a small amount of space between sections. -->
<style type="text/css">
div.section {
  padding-top: 12px;
}
</style>

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Functions used to run the model</h1>

</div>


<p>
<button type="button" class="btn btn-default btn-workflowr btn-workflowr-report" data-toggle="collapse" data-target="#workflowr-report">
<span class="glyphicon glyphicon-list" aria-hidden="true"></span> workflowr <span class="glyphicon glyphicon-ok text-success" aria-hidden="true"></span>
</button>
</p>
<div id="workflowr-report" class="collapse">
<ul class="nav nav-tabs">
<li class="active">
<a data-toggle="tab" href="#summary">Summary</a>
</li>
<li>
<a data-toggle="tab" href="#checks"> Checks <span class="glyphicon glyphicon-ok text-success" aria-hidden="true"></span> </a>
</li>
<li>
<a data-toggle="tab" href="#versions">Past versions</a>
</li>
</ul>
<div class="tab-content">
<div id="summary" class="tab-pane fade in active">
<p>
<strong>Last updated:</strong> 2019-09-09
</p>
<p>
<strong>Checks:</strong> <span class="glyphicon glyphicon-ok text-success" aria-hidden="true"></span> 7 <span class="glyphicon glyphicon-exclamation-sign text-danger" aria-hidden="true"></span> 0
</p>
<p>
<strong>Knit directory:</strong> <code>W_shredder/</code> <span class="glyphicon glyphicon-question-sign" aria-hidden="true" title="This is the local directory in which the code in this file was executed."> </span>
</p>
<p>
This reproducible <a href="http://rmarkdown.rstudio.com">R Markdown</a> analysis was created with <a
  href="https://github.com/jdblischak/workflowr">workflowr</a> (version 1.4.0). The <em>Checks</em> tab describes the reproducibility checks that were applied when the results were created. The <em>Past versions</em> tab lists the development history.
</p>
<hr>
</div>
<div id="checks" class="tab-pane fade">
<div id="workflowr-checks" class="panel-group">
<div class="panel panel-default">
<div class="panel-heading">
<p class="panel-title">
<a data-toggle="collapse" data-parent="#workflowr-checks" href="#strongRMarkdownfilestronguptodate"> <span class="glyphicon glyphicon-ok text-success" aria-hidden="true"></span> <strong>R Markdown file:</strong> up-to-date </a>
</p>
</div>
<div id="strongRMarkdownfilestronguptodate" class="panel-collapse collapse">
<div class="panel-body">
<p>Great! Since the R Markdown file has been committed to the Git repository, you know the exact version of the code that produced these results.</p>
</div>
</div>
</div>
<div class="panel panel-default">
<div class="panel-heading">
<p class="panel-title">
<a data-toggle="collapse" data-parent="#workflowr-checks" href="#strongEnvironmentstrongempty"> <span class="glyphicon glyphicon-ok text-success" aria-hidden="true"></span> <strong>Environment:</strong> empty </a>
</p>
</div>
<div id="strongEnvironmentstrongempty" class="panel-collapse collapse">
<div class="panel-body">
<p>Great job! The global environment was empty. Objects defined in the global environment can affect the analysis in your R Markdown file in unknown ways. For reproduciblity it’s best to always run the code in an empty environment.</p>
</div>
</div>
</div>
<div class="panel panel-default">
<div class="panel-heading">
<p class="panel-title">
<a data-toggle="collapse" data-parent="#workflowr-checks" href="#strongSeedstrongcodesetseed20180716code"> <span class="glyphicon glyphicon-ok text-success" aria-hidden="true"></span> <strong>Seed:</strong> <code>set.seed(20180716)</code> </a>
</p>
</div>
<div id="strongSeedstrongcodesetseed20180716code" class="panel-collapse collapse">
<div class="panel-body">
<p>The command <code>set.seed(20180716)</code> was run prior to running the code in the R Markdown file. Setting a seed ensures that any results that rely on randomness, e.g. subsampling or permutations, are reproducible.</p>
</div>
</div>
</div>
<div class="panel panel-default">
<div class="panel-heading">
<p class="panel-title">
<a data-toggle="collapse" data-parent="#workflowr-checks" href="#strongSessioninformationstrongrecorded"> <span class="glyphicon glyphicon-ok text-success" aria-hidden="true"></span> <strong>Session information:</strong> recorded </a>
</p>
</div>
<div id="strongSessioninformationstrongrecorded" class="panel-collapse collapse">
<div class="panel-body">
<p>Great job! Recording the operating system, R version, and package versions is critical for reproducibility.</p>
</div>
</div>
</div>
<div class="panel panel-default">
<div class="panel-heading">
<p class="panel-title">
<a data-toggle="collapse" data-parent="#workflowr-checks" href="#strongCachestrongnone"> <span class="glyphicon glyphicon-ok text-success" aria-hidden="true"></span> <strong>Cache:</strong> none </a>
</p>
</div>
<div id="strongCachestrongnone" class="panel-collapse collapse">
<div class="panel-body">
<p>Nice! There were no cached chunks for this analysis, so you can be confident that you successfully produced the results during this run.</p>
</div>
</div>
</div>
<div class="panel panel-default">
<div class="panel-heading">
<p class="panel-title">
<a data-toggle="collapse" data-parent="#workflowr-checks" href="#strongFilepathsstrongrelative"> <span class="glyphicon glyphicon-ok text-success" aria-hidden="true"></span> <strong>File paths:</strong> relative </a>
</p>
</div>
<div id="strongFilepathsstrongrelative" class="panel-collapse collapse">
<div class="panel-body">
<p>Great job! Using relative paths to the files within your workflowr project makes it easier to run your code on other machines.</p>
</div>
</div>
</div>
<div class="panel panel-default">
<div class="panel-heading">
<p class="panel-title">
<a data-toggle="collapse" data-parent="#workflowr-checks" href="#strongRepositoryversionstrongahrefhttpsgithubcomlukeholmanWshreddermodeltree967a95c6927cd1191300398b7683d65a0c58b623targetblank967a95ca"> <span class="glyphicon glyphicon-ok text-success" aria-hidden="true"></span> <strong>Repository version:</strong> <a href="https://github.com/lukeholman/W_shredder_model/tree/967a95c6927cd1191300398b7683d65a0c58b623" target="_blank">967a95c</a> </a>
</p>
</div>
<div id="strongRepositoryversionstrongahrefhttpsgithubcomlukeholmanWshreddermodeltree967a95c6927cd1191300398b7683d65a0c58b623targetblank967a95ca" class="panel-collapse collapse">
<div class="panel-body">
<p>
Great! You are using Git for version control. Tracking code development and connecting the code version to the results is critical for reproducibility. The version displayed above was the version of the Git repository at the time these results were generated. <br><br> Note that you need to be careful to ensure that all relevant files for the analysis have been committed to Git prior to generating the results (you can use <code>wflow_publish</code> or <code>wflow_git_commit</code>). workflowr only checks the R Markdown file, but you know if there are other scripts or data files that it depends on. Below is the status of the Git repository when the results were generated:
</p>
<pre><code>
Ignored files:
    Ignored:    .DS_Store
    Ignored:    .Rhistory
    Ignored:    .Rproj.user/
    Ignored:    Proc_B_manuscript/.DS_Store
    Ignored:    code/.DS_Store
    Ignored:    data/
    Ignored:    figures/.DS_Store
    Ignored:    output/

Untracked files:
    Untracked:  .gitignore

Unstaged changes:
    Deleted:    ~$sponse to Proc B.docx

</code></pre>
<p>
Note that any generated files, e.g. HTML, png, CSS, etc., are not included in this status report because it is ok for generated content to have uncommitted changes.
</p>
</div>
</div>
</div>
</div>
<hr>
</div>
<div id="versions" class="tab-pane fade">

<p>
These are the previous versions of the R Markdown and HTML files. If you’ve configured a remote Git repository (see <code>?wflow_git_remote</code>), click on the hyperlinks in the table below to view them.
</p>
<div class="table-responsive">
<table class="table table-condensed table-hover">
<thead>
<tr>
<th>
File
</th>
<th>
Version
</th>
<th>
Author
</th>
<th>
Date
</th>
<th>
Message
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
Rmd
</td>
<td>
<a href="https://github.com/lukeholman/W_shredder_model/blob/3041bd8762987809afdfbc1a3f697ba38889b7cf/analysis/model_functions.Rmd" target="_blank">3041bd8</a>
</td>
<td>
lukeholman
</td>
<td>
2019-09-09
</td>
<td>
First commit
</td>
</tr>
<tr>
<td>
html
</td>
<td>
<a href="https://rawcdn.githack.com/lukeholman/W_shredder_model/3041bd8762987809afdfbc1a3f697ba38889b7cf/docs/model_functions.html" target="_blank">3041bd8</a>
</td>
<td>
lukeholman
</td>
<td>
2019-09-09
</td>
<td>
First commit
</td>
</tr>
</tbody>
</table>
</div>
<hr>
</div>
</div>
</div>
<div id="load-r-libraries" class="section level2">
<h2>Load R libraries</h2>
<pre class="r"><code>packages &lt;- c(&quot;dplyr&quot;, &quot;purrr&quot;, &quot;tidyr&quot;, &quot;stringr&quot;, &quot;reshape2&quot;, &quot;lhs&quot;,
              &quot;parallel&quot;, &quot;Rcpp&quot;, &quot;rslurm&quot;, &quot;readr&quot;, &quot;tibble&quot;)
lapply(packages, library, character.only = TRUE, quietly = TRUE)</code></pre>
</div>
<div id="make-a-table-of-mating-types-and-the-zygotes-they-produce" class="section level2">
<h2>Make a table of mating types and the zygotes they produce</h2>
<p>For every combination of male and female genotypes (i.e. mating types), we can calculate the types of zygotes that can be produced, as well as the relative frequency of each zygote type. It’s computationally efficient to do this before running the simulation and store all the information in a big table, and then look it up later as needed. The types of zygotes produced by each mating type depend on three parameters which are passed as arguments, namely:</p>
<ol style="list-style-type: decimal">
<li><code>W_shredding_rate</code>, the rate at which Z* chromosomes shred susceptible W+ chromosomes in females (<span class="math inline">\(p_{shred}\)</span>)</li>
<li><code>Z_conversion_rate</code>, the rate at which Z* chromosomes convert susceptible Z+ chromosomes in males (<span class="math inline">\(p_{conv}\)</span>)</li>
<li><code>Zr_creation_rate</code>, the rate at which Z* chromosomes convert susceptible Z+ chromosomes to resistant Zr chromosomes in males, for example by non-homologous end joining (NHEJ) (<span class="math inline">\(p_{nhej}\)</span>)</li>
</ol>
<pre class="r"><code>make_mating_type_table &lt;- function(W_shredding_rate, 
                                   Z_conversion_rate,
                                   Zr_creation_rate){
  
  # Step 1: write out the possible alleles at all 3 loci 
  # (the sex chrs, and the two autosomal resistance loci)
  males_sex   &lt;- c(&quot;Z+Z+&quot;, &quot;Z*Z*&quot;, &quot;ZrZr&quot;, &quot;Z*Z+&quot;, &quot;Z*Zr&quot;, &quot;Z+Zr&quot;)
  females_sex &lt;- c(&quot;Z+W+&quot;, &quot;Z*W+&quot;, &quot;ZrW+&quot;, &quot;Z+Wr&quot;, &quot;Z*Wr&quot;, &quot;ZrWr&quot;)
  autosomal_W_rescue &lt;- c(&quot;aa&quot;, &quot;Aa&quot;, &quot;AA&quot;) # Big A is rescue allele for W-shredding
  autosomal_Z_rescue &lt;- c(&quot;bb&quot;, &quot;Bb&quot;, &quot;BB&quot;) # Big B is rescue allele for Z-conversion
  
  # Step 2: Combine the 3 loci&#39;s alleles to find all possible male and female genotypes
  get_possible_genotypes &lt;- function(sex_chr){
    expand.grid(sex_chr, 
                autosomal_W_rescue, 
                autosomal_Z_rescue, 
                stringsAsFactors = FALSE) %&gt;% 
      apply(1, paste0, collapse = &quot;&quot;)
  }
  male_genotypes   &lt;- get_possible_genotypes(sex_chr = males_sex)
  female_genotypes &lt;- get_possible_genotypes(sex_chr = females_sex)
  
  # Step 3: Find all possible mating types
  mating_types &lt;- expand.grid(male_genotypes, 
                              female_genotypes, 
                              stringsAsFactors = FALSE) %&gt;% 
    as.data.frame() %&gt;%
    mutate(male = Var1, female = Var2) %&gt;% 
    select(female, male) 
  
  # Step 4: Find the types and frequencies of gametes produced by each mating type
  
  ## 4a: Identify mating types that experience W-shredding and/or Z-conversion
  ## Note that the A and B alleles are dominant - one copy confers protection
  W.shredding &lt;- grepl(&quot;Z[*]W[+]&quot;, mating_types$female) &amp;
    !(grepl(&quot;A&quot;, mating_types$female))
  Z.conversion &lt;- grepl(&quot;Z[*]Z[+]&quot;, mating_types$male) &amp; 
    !(grepl(&quot;B&quot;, mating_types$male))
  
  ## 4b: Find the proportions of each type of sex chromosome in the gametes, 
  ## allowing for W shredding and Z conversion
  female_gametes_sex &lt;- data.frame(
    type1 = substr(mating_types$female, 1, 2),
    type2 = substr(mating_types$female, 3, 4),
    prop1 = 0.5,
    prop2 = 0.5,
    stringsAsFactors = FALSE) %&gt;%
    mutate(prop1 = replace(prop1, W.shredding, 0.5 + (0.5 * W_shredding_rate)),
           prop2 = 1 - prop1)
 
  ### NB: Z*Z+ males can create Zr gametes by NHEJ, hence &#39;type3&#39; column
  male_gametes_sex &lt;- data.frame(type1 = substr(mating_types$male, 1, 2),
                                 type2 = substr(mating_types$male, 3, 4),
                                 type3 = &quot;Zr&quot;, 
                                 prop1 = 0.5, prop2 = 0, prop3 = 0,
                                 stringsAsFactors = FALSE) %&gt;%
    mutate(prop1 = replace(prop1, Z.conversion, 
                           0.5 + 0.5 * Z_conversion_rate), # fair meiosis + gene conversion
           prop3 = replace(prop3, Z.conversion, 
                           0.5 * Z_conversion_rate * Zr_creation_rate), # gene conversion * Zr_creation_rate
           prop1 = prop1 - prop3, # The new Zr chromosomes are taken out of those that undergo gene conversion
           prop2 = 1 - prop1 - prop3) # The Z+ chromosomes escaping conversion to Z* or NHEJ to Zr
  
  male_gametes_sex[male_gametes_sex$prop3 == 0, 
                   names(male_gametes_sex) %in% c(&quot;type3&quot;, &quot;prop3&quot;)] &lt;- NA
  
  ## 4c: Find the proportions of each autosomal allele in the gametes
  get_gametes_autosomes &lt;- function(genotype_column){
    lapply(strsplit(substr(genotype_column, 5, 8), split = &quot;&quot;), function(x){
      c(paste(x[1], x[3], sep = &quot;&quot;), # NB this bit assumes A and B loci are unlinked
        paste(x[1], x[4], sep = &quot;&quot;),
        paste(x[2], x[3], sep = &quot;&quot;),
        paste(x[2], x[4], sep = &quot;&quot;)
      )
    }) %&gt;% do.call(&quot;rbind&quot;, .)
  }
  female_gametes_autosomes &lt;- get_gametes_autosomes(mating_types$female)
  male_gametes_autosomes   &lt;- get_gametes_autosomes(mating_types$male)
  
  ## 4d: Combine sex and autosomal alleles to find complete 
  ## gametic genotypes, and their corresponding frequencies
  get_complete_gametes &lt;- function(gametes_sex, 
                                   gametes_autosomes,
                                   male){ # logical: are we doing males?
    
    # Make vector showing if there are 1, 2 or 4 possible 
    # autosome genotypes in the gametes, for each of the mating types
    possible.autosomes &lt;- lapply(1:nrow(gametes_autosomes), 
                                 function(i) unique(gametes_autosomes[i, ]))
    n_unique_autosomes &lt;- sapply(possible.autosomes, length)
    
    # Count if there are 2 or 3 possible sex chromosomes in the sperm (from NHEJ)
    # Note that for simpler coding, I treat sex chr homozygotes as having 2 alleles
    # (not 1) for this section (it is quickly fixed later by &#39;simplying&#39;)
    sex &lt;- rep(2, nrow(gametes_sex)) # always 2 for females, and for most males
    if(male) sex[!is.na(gametes_sex$type3)] &lt;- 3 # 3 sex chromosomes in Z*Z+ male sperm
    
    # Paste the sex and autosomes together
    paster &lt;- function(i){ # i is the mating type index
      sex &lt;- sex[i] # 2 or 3 sex chrs in the focal sex for this mating type
      possible.sex.chr &lt;- as.character(gametes_sex[i, 1:sex]) # columns 1-2 or 1-3
      sex.chr.freqs &lt;- as.numeric(gametes_sex[i, 2 + as.numeric(male) + (1:sex)]) # cols 3-4 or 4-6
      possible.autosomes &lt;- possible.autosomes[[i]] # 1, 2 or 4 autosome genotypes
      
      expand.grid(sex = possible.sex.chr, # combine and paste genotypes
                  auto = possible.autosomes, 
                  stringsAsFactors = FALSE) %&gt;%
        mutate(genotype = map2_chr(sex, auto, paste0, collapse = &quot;&quot;)) %&gt;%
        mutate(prop = rep(sex.chr.freqs * 1 / n_unique_autosomes[i], # find corresponding freqs
                          n_unique_autosomes[i])) %&gt;%
        group_by(genotype) %&gt;%
        summarise(prop = sum(prop))
    }
    lapply(1:nrow(gametes_sex), paster) # returns a list
  } # end of get_complete_gametes()
  complete_female_gametes &lt;- get_complete_gametes(female_gametes_sex,
                                                  female_gametes_autosomes,
                                                  male = FALSE)
  complete_male_gametes   &lt;- get_complete_gametes(male_gametes_sex, 
                                                  male_gametes_autosomes,
                                                  male = TRUE)
  
  # Step 5: find the zygote frequencies for each mating type
  get_zygotes &lt;- function(mating_types, 
                          complete_female_gametes, 
                          complete_male_gametes){
    
    n_mating_types &lt;- length(complete_female_gametes)
    
    # Combine the gametes to make zygotes
    zygotes &lt;- lapply(1:n_mating_types, function(i){
      
      combos &lt;- expand.grid(complete_female_gametes[[i]]$genotype, 
                            complete_male_gametes[[i]]$genotype, 
                            stringsAsFactors = FALSE)
      
      props &lt;- expand.grid(complete_female_gametes[[i]]$prop,
                           complete_male_gametes[[i]]$prop)
      combos$prop &lt;- props[,1] * props[,2]
      
      # Discard info on parental origin of alleles
      for(j in 1:nrow(combos)) combos[j, 1:2] &lt;- sort(combos[j, 1:2]) 
      
      # Combine probabilities of identical genotypes
      combos %&gt;% 
        group_by(Var1, Var2) %&gt;%
        summarise(prop = sum(prop)) %&gt;%
        mutate(mating_type = i)
    }) %&gt;% 
      bind_rows() %&gt;% as.data.frame() %&gt;% mutate(genotype = NA)
    
    for(i in 1:nrow(zygotes)){
      A_geno &lt;- c(substr(zygotes$Var1[i], 3, 3),
                  substr(zygotes$Var2[i], 3, 3)) %&gt;%
        sort(decreasing = TRUE)
      
      B_geno &lt;- c(substr(zygotes$Var1[i], 4, 4),
                  substr(zygotes$Var2[i], 4, 4)) %&gt;%
        sort(decreasing = TRUE)
      sex_geno &lt;- c(substr(zygotes$Var1[i], 1, 2),
                    substr(zygotes$Var2[i], 1, 2)) 
      forwards &lt;- paste0(sex_geno, collapse = &quot;&quot;)
      if(forwards %in% c(males_sex, females_sex)){ # I define Z*Z+ as a &#39;real&#39; genotype but not Z+Z*
        zygotes$genotype[i] &lt;- paste0(c(forwards, 
                                        A_geno,
                                        B_geno),
                                      collapse = &quot;&quot;)
      } else {  # if genotype is not in the list of possible genos, paste it the other way around
        zygotes$genotype[i] &lt;- paste0(c(paste0(rev(sex_geno), collapse = &quot;&quot;), 
                                        A_geno,
                                        B_geno),
                                      collapse = &quot;&quot;)
      }
    } # end of for loop
    data.frame(mating_type = zygotes$mating_type,
               mother = mating_types$female[zygotes$mating_type],
               father = mating_types$male[zygotes$mating_type],
               zygote = zygotes$genotype,
               prop = zygotes$prop, stringsAsFactors = FALSE) 
  } # end of get_zygotes()
  get_zygotes(mating_types, complete_female_gametes, complete_male_gametes)
}</code></pre>
</div>
<div id="function-to-add-de-novo-resistance-mutations" class="section level2">
<h2>Function to add <em>de novo</em> resistance mutations</h2>
<p>This function supplements a mating_type_table with all the extra progeny classes that can appear by a mutation of one of the normal progeny classes. We assume that Z+ chromosomes can mutate to Zr and <em>vice versa</em>, and W+ to Wr and <em>vice versa</em>. We assume that mutations are equally likely in both directions, meaning that mutation will not consistently affect the allele frequencies. Also, in simulations where the <code>Zr_mutation_rate</code> and <code>Wr_mutation_rate</code> are non-zero, we set the initial frequency of Zr and/or Wr to the mutation rate (so that resistance mutations will generally already be present at the start of the burn in phase)</p>
<pre class="r"><code>add_mutants &lt;- function(mating_type_table, Zr_mutation_rate, Wr_mutation_rate){
  
  zygote_has_two_Z &lt;- grepl(&quot;Z[+]Z[+]&quot;, mating_type_table$zygote)
  zygote_has_one_Z &lt;- grepl(&quot;Z[+]&quot;, mating_type_table$zygote) &amp; !zygote_has_two_Z
  zygote_has_two_Zr &lt;- grepl(&quot;ZrZr&quot;, mating_type_table$zygote)
  zygote_has_one_Zr &lt;- grepl(&quot;Zr&quot;, mating_type_table$zygote) &amp; !zygote_has_two_Zr
  zygote_has_W &lt;- grepl(&quot;W[+]&quot;, mating_type_table$zygote)
  zygote_has_Wr &lt;- grepl(&quot;Wr&quot;, mating_type_table$zygote)
  
  # Create the mutant zygotes...
  Z_mutants1 &lt;- mating_type_table %&gt;% # single Z+ -&gt; Zr mutants in Z+/- individuals
    filter(zygote_has_one_Z) %&gt;%
    mutate(zygote = str_replace_all(zygote, &quot;Z[+]&quot;, &quot;Zr&quot;),
           prop = prop * Zr_mutation_rate)
  
  Z_mutants2 &lt;- mating_type_table %&gt;% # single Z+ -&gt; Zr mutants in Z+Z+ individuals
    filter(zygote_has_two_Z) %&gt;%
    mutate(zygote = str_replace_all(zygote, &quot;Z[+]Z[+]&quot;, &quot;Z+Zr&quot;),
           prop = prop * Zr_mutation_rate * 2)
  
  Z_mutants3 &lt;- mating_type_table %&gt;% # double Z+ -&gt; Zr mutants in Z+Z+ individuals
    filter(zygote_has_two_Z) %&gt;%
    mutate(zygote = str_replace_all(zygote, &quot;Z[+]Z[+]&quot;, &quot;ZrZr&quot;),
           prop = prop * Zr_mutation_rate * Zr_mutation_rate)
  
  Zr_mutants1 &lt;- mating_type_table %&gt;% # single Zr -&gt; Z+ mutants in Zr/- individuals
    filter(zygote_has_one_Zr) %&gt;%
    mutate(zygote = str_replace_all(zygote, &quot;Zr&quot;, &quot;Z+&quot;),
           prop = prop * Zr_mutation_rate)
  
  Zr_mutants2 &lt;- mating_type_table %&gt;% # single Zr -&gt; Z+ mutants in ZrZr individuals
    filter(zygote_has_two_Zr) %&gt;%
    mutate(zygote = str_replace_all(zygote, &quot;ZrZr&quot;, &quot;Z+Zr&quot;),
           prop = prop * Zr_mutation_rate * 2)
  
  Zr_mutants3 &lt;- mating_type_table %&gt;% # double Zr -&gt; Z+ mutants in ZrZr individuals
    filter(zygote_has_two_Zr) %&gt;%
    mutate(zygote = str_replace_all(zygote, &quot;ZrZr&quot;, &quot;Z+Z+&quot;),
           prop = prop * Zr_mutation_rate * Zr_mutation_rate)
  
  W_mutants &lt;- mating_type_table %&gt;% 
    filter(zygote_has_W) %&gt;%
    mutate(zygote = str_replace_all(zygote, &quot;W[+]&quot;, &quot;Wr&quot;),
           prop = prop * Wr_mutation_rate)
  
  Wr_mutants &lt;- mating_type_table %&gt;% 
    filter(zygote_has_Wr) %&gt;%
    mutate(zygote = str_replace_all(zygote, &quot;Wr&quot;, &quot;W+&quot;),
           prop = prop * Wr_mutation_rate)
  
  # Subtract the mutants from the non-mutants&#39; frequencies
  mating_type_table$prop[zygote_has_one_Z] &lt;- 
    mating_type_table$prop[zygote_has_one_Z] - Z_mutants1$prop
  mating_type_table$prop[zygote_has_two_Z] &lt;- 
    mating_type_table$prop[zygote_has_two_Z] - Z_mutants2$prop - Z_mutants3$prop
  mating_type_table$prop[zygote_has_one_Zr] &lt;- 
    mating_type_table$prop[zygote_has_one_Zr] - Zr_mutants1$prop
  mating_type_table$prop[zygote_has_two_Zr] &lt;- 
    mating_type_table$prop[zygote_has_two_Zr] - Zr_mutants2$prop - Zr_mutants3$prop
  mating_type_table$prop[zygote_has_W] &lt;- 
    mating_type_table$prop[zygote_has_W] - W_mutants$prop
  mating_type_table$prop[zygote_has_Wr] &lt;- 
    mating_type_table$prop[zygote_has_Wr] - Wr_mutants$prop
  
  rbind(mating_type_table, # bind mutants onto the mating type table, combine and simplify
        Z_mutants1, Z_mutants2, Z_mutants3,
        Zr_mutants1, Zr_mutants2, Zr_mutants3, 
        W_mutants, Wr_mutants) %&gt;%
    group_by(mating_type, mother, father, zygote) %&gt;%
    summarise(prop = sum(prop)) %&gt;%
    as.data.frame() %&gt;%
    arrange(mating_type, mother, father, -prop) %&gt;%
    mutate(mating_type = as.character(mating_type),
           mother = as.character(mother),
           father = as.character(father))
}

# Helper function to convert the zygote frequencies to a cumulative sum.
# To create each offspring, we later roll random numbers between 0 and 1 with runif(),
# then see which is the largest index of &#39;prop&#39; that is less than the random number.
# This will efficiently determine which zygote is produced, allowing us to roll all the 
# random numbers needed in one step only (making use of vectorisation for speed)
convert_probabilities &lt;- function(mating_type_table){
  
  # Remove zygote classes with zero probability (e.g. because drive is 100% and Z+ or W+ are missing)
  mating_type_table &lt;- mating_type_table %&gt;% filter(prop != 0) 
  
  # Arrange probs from biggest to smallest within each mating type
  mating_type_table &lt;- mating_type_table %&gt;% 
    split(mating_type_table$mating_type) %&gt;%
    map(~ .x %&gt;% arrange(-prop)) %&gt;%
    bind_rows()
  
  # convert to cumsum probabilities; for example,
  # The classic 1:2:1 Mendelian ratio has genotype frequencies of .25, .5, and .25
  # This is represented as c(0, 0.25, 0.75). 
  # Rolling runif() 0 to 0.25 yields geno 1, &gt;.25 gives genotype 2, and &gt;.75 gives genotype 3
  mating_type_table$prop &lt;- mating_type_table$prop %&gt;% 
    split(mating_type_table$mating_type) %&gt;% # Get the vector of zygote probs for each mating type
    map(function(focal_props){
      focal_props &lt;- cumsum(focal_props) 
      c(0, focal_props[-length(focal_props)]) 
    }) %&gt;% combine()
  
  # Remove numbers so close 1 they are converted to 1 by floating point arithmetic
  # Effectively, we assume that sufficiently rare progeny classes never appear (&lt;10^-16 I think)
  mating_type_table %&gt;% filter(prop != 1)
}</code></pre>
</div>
<div id="function-to-make-a-table-of-every-genotypes-fitness" class="section level2">
<h2>Function to make a table of every genotype’s fitness</h2>
<p>We assume that individuals with wild type sex chromosomes (Z+ and W+), as well as non-resistant autosomal alleles (genotype aabb), have a fitness of 1. The resistant alleles (Zr, Wr, A, and B), as well as the driving Z* allele, all potentially incur costs (in the eventual paper, only the cost of Z* was actually modelled: I set all other costs to zero for brevity). These costs are multiplicative, such that the fitness cost <span class="math inline">\(c\)</span> of e.g. having both Zr and A is <span class="math inline">\(c = 1 {\times} (1 - c_{Zr}) {\times} (1 - c_{A})\)</span>. The costs are also all dominant: having one copy of Z*, Zr, Wr, A, and B is equally costly as having two.</p>
<pre class="r"><code>make_fitness_table &lt;- function(cost_Zdrive_female,
                               cost_Zdrive_male,
                               cost_Wr,
                               cost_Zr,
                               cost_A,
                               cost_B,
                               mating_type_table){
  
  female_fitnesses &lt;- mating_type_table %&gt;% 
    select(mother) %&gt;% distinct() %&gt;%
    rename(genotype = mother) %&gt;%
    mutate(w = 1,
           w = replace(w, grepl(&quot;Wr&quot;, genotype), (1 - cost_Wr)))
  
  female_fitnesses$w[grep(&quot;Z[*]&quot;, female_fitnesses$genotype)] &lt;- 
    female_fitnesses$w[grep(&quot;Z[*]&quot;, female_fitnesses$genotype)] * (1 - cost_Zdrive_female)
  
  male_fitnesses &lt;- mating_type_table %&gt;% 
    select(father) %&gt;% distinct() %&gt;%
    rename(genotype = father) %&gt;%
    mutate(w = 1,
           w = replace(w, grepl(&quot;Z[*]&quot;, genotype), (1 - cost_Zdrive_male)))
  
  fitness &lt;- rbind(female_fitnesses, male_fitnesses)
  
  fitness$w[grep(&quot;Zr&quot;, fitness$genotype)] &lt;- 
    fitness$w[grep(&quot;Zr&quot;, fitness$genotype)] * (1 - cost_Zr) 
  fitness$w[grep(&quot;A&quot;, fitness$genotype)] &lt;- 
    fitness$w[grep(&quot;A&quot;, fitness$genotype)] * (1 - cost_A)
  fitness$w[grep(&quot;B&quot;, fitness$genotype)] &lt;- 
    fitness$w[grep(&quot;B&quot;, fitness$genotype)] * (1 - cost_B)
  
  fitness %&gt;% rename(fitness = w) 
}</code></pre>
</div>
<div id="function-to-create-the-starting-population" class="section level2">
<h2>Function to create the starting population</h2>
<p>This function creates a population with a specified size, spread evenly across a specified number of patches, with specified allele frequencies in Hardy-Weinberg genotype frequencies.</p>
<pre class="r"><code>make_initial_population &lt;- function(initial_Zdrive, 
                                    initial_Zr,
                                    initial_Wr,
                                    initial_A,
                                    initial_B,
                                    initial_pop_size,
                                    n_patches,
                                    fitness_table){
  
  initial_freqs &lt;- fitness_table %&gt;% 
    rename(freq = fitness) %&gt;% 
    mutate(sex = substr(genotype, 1, 4),
           auto1 = substr(genotype, 5, 6),
           auto2 = substr(genotype, 7, 8),
           freq = 0) 
  Z &lt;- (1 - initial_Zdrive - initial_Zr)
  Zdrive &lt;- initial_Zdrive
  Zr &lt;- initial_Zr
  W &lt;-  (1 - initial_Wr)
  Wr &lt;- initial_Wr
  initial_freqs$sex[initial_freqs$sex == &quot;Z+Z+&quot;] &lt;- Z ^ 2
  initial_freqs$sex[initial_freqs$sex == &quot;Z*Z*&quot;] &lt;- Zdrive ^ 2
  initial_freqs$sex[initial_freqs$sex == &quot;ZrZr&quot;] &lt;- Zr ^ 2
  initial_freqs$sex[initial_freqs$sex == &quot;Z*Z+&quot;] &lt;- 2 * Zdrive * Z
  initial_freqs$sex[initial_freqs$sex == &quot;Z+Zr&quot;] &lt;- 2 * Z * Zr
  initial_freqs$sex[initial_freqs$sex == &quot;Z*Zr&quot;] &lt;- 2 * Zdrive * Zr
  initial_freqs$sex[initial_freqs$sex == &quot;Z+W+&quot;] &lt;- Z * W
  initial_freqs$sex[initial_freqs$sex == &quot;Z*W+&quot;] &lt;- Zdrive * W
  initial_freqs$sex[initial_freqs$sex == &quot;ZrW+&quot;] &lt;- Zr * W
  initial_freqs$sex[initial_freqs$sex == &quot;Z+Wr&quot;] &lt;- Z * Wr
  initial_freqs$sex[initial_freqs$sex == &quot;Z*Wr&quot;] &lt;- Zdrive * Wr
  initial_freqs$sex[initial_freqs$sex == &quot;ZrWr&quot;] &lt;- Zr * Wr
  
  initial_freqs[initial_freqs == &quot;aa&quot;] &lt;- (1 - initial_A) ^ 2
  initial_freqs[initial_freqs == &quot;Aa&quot;] &lt;- 2 * initial_A * (1 - initial_A)
  initial_freqs[initial_freqs == &quot;AA&quot;] &lt;- initial_A ^ 2
  
  initial_freqs[initial_freqs == &quot;bb&quot;] &lt;- (1 - initial_B) ^ 2
  initial_freqs[initial_freqs == &quot;Bb&quot;] &lt;- 2 * initial_B * (1 - initial_B)
  initial_freqs[initial_freqs == &quot;BB&quot;] &lt;- initial_B ^ 2
  for(i in 2:ncol(initial_freqs)) initial_freqs[, i] &lt;- as.numeric(initial_freqs[, i])
  initial_freqs$freq &lt;- with(initial_freqs, sex * auto1 * auto2)
  
  data.frame(genotype = sample(initial_freqs$genotype,
                               initial_pop_size,
                               prob = initial_freqs$freq,
                               replace = TRUE),
             patch = sample(n_patches, initial_pop_size, replace = TRUE),
             stringsAsFactors = FALSE) %&gt;%
    group_by(patch, genotype) %&gt;%
    summarise(n = n()) %&gt;% arrange(patch, -n) %&gt;%
    ungroup()
}</code></pre>
<!-- test_pop <- make_initial_population(0.1, 0.1, 0.1, 0.1, 0.1, initial_pop_size = 1000, n_patches = 10, fitness_table = make_fitness_table()) -->
</div>
<div id="function-to-release-the-z-individuals" class="section level2">
<h2>Function to release the Z* individuals</h2>
<p>This functions adds <code>release_size</code> Z*Z* males to the population, simulating a release of the engineered Z-linked allele. Either the release is localised to one random patch, or the release is randomly scattered across all patches with equal probability using <code>rmultinom</code>.</p>
<pre class="r"><code>release_Zd_individuals &lt;- function(parent_list, n_patches, fitness_table, release_size, release_strategy){
  
  if(release_strategy == &quot;one_patch&quot;){
    
    # Release drive males in most productive patch
    patch_productivities &lt;- parent_list[[1]] %&gt;%
      group_by(patch) %&gt;%
      summarise(productivity = sum(fecundity))

    released_males &lt;- data.frame(
      patch = with(patch_productivities, patch[which.max(productivity)]), 
      genotype = &quot;Z*Z*aabb&quot;, 
      n = release_size, 
      fitness = fitness_table$fitness[fitness_table$genotype == &quot;Z*Z*aabb&quot;],
      stringsAsFactors = FALSE)
  }
  
  # Scatter the release randomly and evenly across all patches
  if(release_strategy == &quot;all_patches&quot;){
    
    released_males &lt;- data.frame(
      patch = 1:n_patches, 
      genotype = &quot;Z*Z*aabb&quot;, 
      n = c(rmultinom(1, release_size, rep(1 / n_patches, n_patches))), 
      fitness = fitness_table$fitness[fitness_table$genotype == &quot;Z*Z*aabb&quot;],
      stringsAsFactors = FALSE) 
  }
  
  list(
    parent_list[[1]], # females
    rbind(parent_list[[2]] %&gt;% select(-is_female) %&gt;% as.data.frame(), 
          released_males) %&gt;% # original+released males
      group_by(patch, genotype, fitness) %&gt;%
      summarise(n = sum(n)) %&gt;% 
      ungroup() %&gt;% as.data.frame()
  )
}</code></pre>
</div>
<div id="functions-to-calculate-density-dependent-fecundity" class="section level2">
<h2>Functions to calculate density-dependent fecundity</h2>
<div id="calculate-density-at-the-global-scale" class="section level3">
<h3>Calculate density at the global scale</h3>
<pre class="r"><code># females are weighted by their fitness, 
# males are considered all the same, but are weighted by male_weighting 
calc_global_density &lt;- function(pop, male_weighting){
  sum(pop$n[pop$is_female] * pop$fitness[pop$is_female]) + 
    sum(pop$n[!pop$is_female]) * male_weighting
}</code></pre>
</div>
<div id="calculate-density-at-the-local-scale" class="section level3">
<h3>Calculate density at the local scale</h3>
<pre class="r"><code>calc_patch_densities &lt;- function(patch_densities, 
                                 n_patches, male_weighting){
  data.frame( 
    patch = patch_densities$patch,
    density = n_patches * 
      (patch_densities$weighted_number_of_females + 
                   male_weighting * patch_densities$number_of_males)
  )
}</code></pre>
</div>
</div>
<div id="function-to-pick-the-parents-of-the-next-generation" class="section level2">
<h2>Function to pick the parents of the next generation</h2>
<p>This function is run once per generation in the simulation. It randomly picks the male and female parents of each new offspring, where parents with high fitness genotypes (e.g. Z+Z+aabb) are more likely to be picked than parents with low fitness genotypes (e.g. Z*Z*AABB). We assume a promiscuous mating system, such that individuals of both sexes potentially produce offspring with multiple partners. The fitness of each individual is stochastic, so each generation there will be some males and females that do not breed, and others that reproduce a lot.</p>
<p>We assume that all mating occurs within patches. Males thus always compete locally, meaning that alleles in males always experience “soft” selection (resulting from differences in lifetime mating success). For females, we model global and local competition separately (corresponding to hard and soft selection respectively). Selection on females results from differences in the lifetime number of offspring produced (this could be fecundity and/or viability selection).</p>
<p>We assume that under ideal conditions (e.g. in a near-empty patch or meta-population), a female with genotypic fitness <span class="math inline">\(w_j\)</span> has an expected fecundity of <span class="math inline">\(w_j * max_fecundity\)</span>, while under crowded conditions, each females’ expected fecundity tends towards <span class="math inline">\(0\)</span>.</p>
<p>Under soft selection, a female in a PATCH containing <span class="math inline">\(n_f\)</span> females has an expected fecundity of <span class="math inline">\(w_j * maxFecundity / (nPatches * ∑_i n_f w_i)\)</span> offspring.</p>
<p>Under hard selection, a female in a METAPOPULATION containing <span class="math inline">\(n_f\)</span> females has an expected fecundity of <span class="math inline">\(w_j * maxFecundity / (∑_i n_f w_i)\)</span> offspring.</p>
<p>The actual number of progeny per female is generated stochastically by drawing from a Poisson distribution.</p>
<!-- # I snipped the Rcpp version because it doesn't work well on the computer cluster - shame bc it's faster than R -->
<!-- # cppFunction('CharacterVector random_picker( -->
<!-- #     NumericVector rand, -->
<!-- #     NumericVector probabilities, -->
<!-- #     CharacterVector genotypes) { -->
<!-- #   int nRand = rand.size(); -->
<!-- #   int nGenotypes = genotypes.size(); -->
<!-- #   CharacterVector out(nRand); -->
<!-- #  -->
<!-- #   /* First check if there is only one genotype: no random picking needed */ -->
<!-- #   if(nGenotypes == 1){ -->
<!-- #     for(int i = 0; i < nRand; ++i) { -->
<!-- #       out[i] = genotypes[0]; -->
<!-- #     } -->
<!-- #     return out; -->
<!-- #   } -->
<!-- #  -->
<!-- #   int stoppingPoint = nGenotypes - 1; -->
<!-- #   LogicalVector booleans(nGenotypes); -->
<!-- #   booleans[0] = true; -->
<!-- #   int picked = 0; -->
<!-- #   bool keepGoing = true; -->
<!-- #  -->
<!-- #   /* Loop over the random numbers in rand */ -->
<!-- #   for(int i = 0; i < nRand; ++i) { -->
<!-- #  -->
<!-- #     /* Find which elements of probabilities are < rand[i] */ -->
<!-- #     for(int j = 1; j < nGenotypes; ++j) { -->
<!-- #       booleans[j] = rand[i] > probabilities[j]; -->
<!-- #     } -->
<!-- #  -->
<!-- #     picked = 0; -->
<!-- #     keepGoing = true; -->
<!-- #  -->
<!-- #     /* Loop over the booleans, and find the last element that is true */ -->
<!-- #     while(keepGoing == true) { -->
<!-- #        if(booleans[picked + 1] == true) { -->
<!-- #           picked += 1; -->
<!-- #           if(picked == stoppingPoint) keepGoing = false; -->
<!-- #        } else keepGoing = false; -->
<!-- #     } -->
<!-- #  -->
<!-- #     out[i] = genotypes[picked]; -->
<!-- #   } -->
<!-- #   return out; -->
<!-- # }') -->
<!-- # #  -->
<!-- # x <- runif(100) -->
<!-- # random_picker(x, c(0, 0.5, 0.9, 0.95), c("A", "B", "C", "D")) -->
<!-- # random_picker_R(x, c(0, 0.5, 0.9, 0.95), c("A", "B", "C", "D")) -->
<!-- # microbenchmark::microbenchmark(C = random_picker(x, c(0, 0.5, 0.9, 0.95), c("A", "B", "C", "D")), -->
<!-- #                R = random_picker_R(x, c(0, 0.5, 0.9, 0.95), c("A", "B", "C", "D")), times = 10000) -->
<pre class="r"><code># Helper function
# given a vector of pre-rolled uniform random numbers (rand), a vector of cumulative sum probabilities,
# and a vector of the genotypes to which probability corresponds, pick the genotypes
random_picker &lt;- function(rand, probabilities, genotypes){
  sapply(1:length(rand), function(i) genotypes[sum(rand[i] &gt; probabilities)])
}

# Calculate (global) density-dependent fecundity accrording to Richards model (Fowler 1981):
# Females of genotype i have expected fecundity of 1 + w_i * max_fecundity * (Richards density regulation)
calc_fecundities &lt;- function(females, 
                             max_fecundity, 
                             carrying_capacity, 
                             density_dependence_shape){
  
  # Due to migration and some other factors, it is possible to get density &gt; carrying capacity,
  # which causes non-sensical values for female fecundity. Here, I
  # deal with this by setting density = carrying capacity
  females$density[females$density &gt; carrying_capacity] &lt;- carrying_capacity
  
  # Calculate expected female fecundity for each patch/genotype combination
  fecundity &lt;- females$n * females$fitness * 
    (2 + max_fecundity * (1 - (females$density / carrying_capacity) ^ density_dependence_shape))
  
  # Roll Poisson random numbers using expected values
  fecundity &lt;- rpois(nrow(females), fecundity)
  
  # Check if the number of progeny exceeds the carrying capacity
  if(sum(fecundity) &gt; carrying_capacity){

    # If it does, randomly select `carrying_capacity` surviving offspring
    # This makes a df with col1 = rows in `females`, col2 is their fecundity
    to_keep &lt;- melt(table(sample(rep(1:nrow(females), 
                          times = fecundity),
                      carrying_capacity)), 
                    value.name = &quot;fecundity&quot;)
    females$fecundity &lt;- 0
    females$fecundity[to_keep$Var1] &lt;- to_keep$fecundity
    
  } else {
    females$fecundity &lt;- fecundity
  }
  females
}

pick_mothers &lt;- function(pop, fitness_table, n_patches,
                         softness, 
                         male_weighting, 
                         max_fecundity,
                         carrying_capacity,
                         density_dependence_shape){
  
  pop &lt;- pop %&gt;% 
    filter(n != 0) %&gt;% # double check there are no empty genotypes....
    left_join(fitness_table, by = &quot;genotype&quot;) %&gt;% # add fitness column
    mutate(is_female = grepl(&quot;W&quot;, genotype)) # Add column of TRUE/FALSE for sex

  # Make df of the patch-specific male and female counts
  # (needed later as well as immediately)
  patch_densities &lt;- pop %&gt;% 
    group_by(patch) %&gt;% 
    summarise(weighted_number_of_females = sum(n[is_female] * fitness[is_female]),
              number_of_males = sum(n[!is_female])) 
  
  
  # Calculate global density, unless selection is 100% soft
  # Note that all-male and all-female patches still contribute to the global density
  if(softness != 1) {
    global_density &lt;- calc_global_density(pop, male_weighting)
  }
  
  # here are the parents eligible to breed (trim off all single-sex patches)
  patch_densities &lt;- patch_densities %&gt;%
    filter(weighted_number_of_females != 0 &amp; number_of_males != 0)
  
  # Return NULL if pop has gone extinct
  if(nrow(patch_densities) == 0) return(NULL) 
  
  pop     &lt;- pop %&gt;% filter(patch %in% patch_densities$patch)
  females &lt;- pop %&gt;% filter(is_female)
  males   &lt;- pop %&gt;% filter(!is_female) 

  # under totally hard selection, we can skip calculation of the patch-specific densities
  if(softness == 0){ 
    females$density &lt;- rep(global_density, nrow(females))
  } else { # under (partially or fully) soft selection, 
           # calculate the patch-specific densities 
    patch_densities &lt;- calc_patch_densities(
      patch_densities, n_patches, male_weighting)
    
    if(softness != 1){ # softness == 1, only local density matters
      # for 0 &lt; softness &lt; 1, we need both local and global density
      patch_densities$density &lt;-
        softness * patch_densities$density + 
        (1 - softness) * global_density
    } 
    females &lt;- left_join(females, patch_densities, by = &quot;patch&quot;) 
  }
  
  # Randomly generate fecundity from the combined expected reproductive 
  # output of each genotype/patch combination. e.g. 10 ZWaabb females,
  # with expected fecundity of 2.5 each, have a total of rpois(1, 25) offspring
  females &lt;- calc_fecundities(females, 
                              max_fecundity, 
                              carrying_capacity, 
                              density_dependence_shape)
  
  # Number of offspring born, by mother genotype and patch: 
  females &lt;- females %&gt;% 
    select(patch, genotype, fecundity)
  
  # This is `parent_list` for the next function
  return(list(females, males))
}

pick_fathers &lt;- function(parent_list){
  
  if(is.null(parent_list)) return(NULL) # Return NULL if pop has gone extinct
  
  offspring_per_patch &lt;- parent_list[[1]] %&gt;%
    group_by(patch) %&gt;% 
    summarise(offspring = sum(fecundity)) %&gt;%
    filter(offspring != 0)

  # Generate total_offspring random numbers to determine each offspring&#39;s father,
  # And split these numbers by patch
  rand &lt;- runif(sum(offspring_per_patch$offspring)) %&gt;% 
    split(rep(offspring_per_patch$patch, 
              times = offspring_per_patch$offspring))
  
  if(length(rand) &lt; 1) print(&quot;This one is bad&quot;)
  
  # Now loop over all the patches with &gt;0 offspring, and find fathers 
  # for individual offspring (therefore, we assume promiscuity)
  lapply(1:nrow(offspring_per_patch), function(i){
    
    # get the numbers of each male and female genotype in the focal patch
    females_in_patch &lt;- parent_list[[1]] %&gt;% 
      filter(patch == offspring_per_patch$patch[i])
    males_in_patch   &lt;- parent_list[[2]] %&gt;% 
      filter(patch == offspring_per_patch$patch[i])

    # Find the siring probability of each male genotype, convert to cumsum
    father_probabilities &lt;- males_in_patch$n * males_in_patch$fitness
    
    father_probabilities &lt;- cumsum(father_probabilities / sum(father_probabilities))
    
    data.frame(patch = offspring_per_patch$patch[i],
               parents = paste(rep(females_in_patch$genotype,
                                   times = females_in_patch$fecundity), 
                               random_picker(rand[[i]], 
                                             c(0, father_probabilities[-length(father_probabilities)]), 
                                             males_in_patch$genotype)), 
               stringsAsFactors = FALSE)
  }) %&gt;% do.call(&quot;rbind&quot;, .) %&gt;%
    group_by(patch, parents) %&gt;% 
    summarise(n = n()) %&gt;% as.data.frame()
}</code></pre>
</div>
<div id="function-to-create-offspring-by-random-meiosis-and-mutation" class="section level2">
<h2>Function to create offspring by random meiosis and mutation</h2>
<p>Most of the hard work has already been done, when we created the mating_type_table above. This function takes a data frame of parents (giving the number of offspring produced by each different mating type in each patch), looks up the expected zygote frequencies in <code>mating_type_table</code>, and then randomly generates the zygotes.</p>
<pre class="r"><code>make_offspring &lt;- function(parents, mating_type_table){
  
  if(is.null(parents) || sum(parents$n) == 0) return(NULL) # Return NULL if pop has gone extinct
  
  # Number of offspring from each mating type, summed across patches
  offspring_per_mating_type &lt;- parents %&gt;%
    group_by(parents) %&gt;%
    summarise(n = sum(n))
  
  # Restrict the big mating_type_table, for faster searching
  mating_type_table &lt;- mating_type_table %&gt;% 
    filter(parents %in% offspring_per_mating_type$parents)
  
  # Generate a random number for every offspring, and split between each of the i mating types
  rand &lt;- runif(sum(parents$n)) %&gt;% 
    split(rep(offspring_per_mating_type$parents,
                    times = offspring_per_mating_type$n))
  
  # Loop over all the mating types 
  lapply(1:nrow(offspring_per_mating_type), function(i) {
    focal.parents &lt;- parents %&gt;% # Get the patch ids for each offspring (same as parents&#39;)
      filter(parents == offspring_per_mating_type$parents[i])
    
    focal.zygotes &lt;- mating_type_table %&gt;% # Get the zygote proportions for the focal mating type
      filter(parents == offspring_per_mating_type$parents[i])
    
    data.frame(genotype = random_picker(rand[[i]], 
                                        focal.zygotes$prop,
                                        focal.zygotes$zygote),
               patch = rep(focal.parents$patch,
                           times = focal.parents$n),
               stringsAsFactors = FALSE) %&gt;%
      group_by(patch, genotype) %&gt;%
      summarise(n = n())
  }) %&gt;% bind_rows() %&gt;%
    group_by(patch, genotype) %&gt;%
    summarise(n = sum(n)) %&gt;%
    ungroup() 
}</code></pre>
</div>
<div id="function-implementing-migration" class="section level2">
<h2>Function implementing migration</h2>
<p>This function moves newly-born indiviuals to a different randomly-selected patch. Males and females potentially migrate at different rates.</p>
<pre class="r"><code>migrate_population &lt;- function(pop, 
                               n_patches,
                               patch_landing_probabilities, # passed as arg to save time
                               male_migration_prob,
                               female_migration_prob,
                               migration_type){
  
  if(is.null(pop)) return(NULL) # Return NULL if pop has gone extinct
  if(n_patches == 1) return(pop) # don&#39;t do anything if there is only one patch
  
  nrow_pop &lt;- nrow(pop)
  migration_probs &lt;- rep(male_migration_prob, nrow_pop)
  migration_probs[grep(&quot;W&quot;, pop$genotype)] &lt;- female_migration_prob
  
  # For efficiency, the call to rmultinom() below allows migrants 
  # to return to their home patch, which would mean they are not really migrants!
  # To make sure that male_migration_prob and female_migration_prob correctly
  # give the % individuals that move to another patch, the function
  # internally boosts the migration rates by a constant, c, which varies
  # based on how many patches there are. 
  # To understand how I derived c, here&#39;s the algebra.
  
  # The problem is that the following inequality is always true if there is a finite number of patches
  # real_migration_rate &lt; stated_migration_rate * (1 - proportion.returning.to.same.patch)
  
  # To make real_migration_rate = stated_migration_rate, we can add a constant c,
  # And solve for c when real_migration_rate = stated_migration_rate:
  # real_migration_rate = (stated_migration_rate + c) * 
  #                                           (1 - proportion.returning.to.same.patch)
  # Rearranging, we find that c is:
  # c = (stated_migration_rate / (1 - fraction.returning)) - stated_migration_rate
  
  if(migration_type == &quot;global&quot;) {
    migration_probs &lt;- migration_probs + # Add on c. Not needed for local dispersal.
      (migration_probs / (1 - patch_landing_probabilities[1])) - migration_probs
  }
  
  n_migrants &lt;- rbinom(nrow_pop, pop$n, prob = migration_probs) 
  if(sum(n_migrants) == 0) return(pop) # return pop if there are no migrants
  
  pop$n &lt;- pop$n - n_migrants # remove migrants from their original patches
  
  migrants &lt;- pop %&gt;% # Find the number of migrants for each genotype
    mutate(n = n_migrants) %&gt;%
    filter(n != 0) 
  
  if(migration_type == &quot;global&quot;){

    migrants &lt;- migrants %&gt;% # tally the migrants&#39; genotypes
    group_by(genotype) %&gt;%
      summarise(n = sum(n))
    
    pop &lt;- rbind(pop, # Find new patches for the migrants, and return them to the pop
                 lapply(1:nrow(migrants), function(i){ # for each genotype in the migrant pool...
                   data.frame(patch = 1:n_patches,
                              genotype = migrants$genotype[i],
                              n = rmultinom(1, 
                                            size = migrants$n[i], 
                                            prob = patch_landing_probabilities)[,1],
                              stringsAsFactors = FALSE)
                 }) %&gt;% bind_rows() %&gt;% filter(n != 0)) 
  } else { # else for LOCAL migration...
    pop &lt;- rbind(
      pop,
      data.frame(patch = rep(migrants$patch, migrants$n),
                 genotype = rep(migrants$genotype, migrants$n),
                 n = 1,
                 stringsAsFactors = FALSE) %&gt;%
        mutate(patch = patch + sample(c(-1, 1), n(), replace = TRUE), # add -1 or +1 to patch address
               patch = replace(patch, patch == 0, n_patches),  # going to patch 0 brings you to patch k
               patch = replace(patch, patch &gt; n_patches, 1)))  # going to patch k+1 brings you to patch 1 
  }
  pop %&gt;%
    group_by(patch, genotype) %&gt;%
    summarise(n = sum(n)) %&gt;%
    ungroup()
}</code></pre>
</div>
<div id="function-to-calculate-allele-frequencies-in-the-population" class="section level2">
<h2>Function to calculate allele frequencies in the population</h2>
<pre class="r"><code>get_allele_freqs &lt;- function(pop, generation){
  pop_size &lt;- sum(pop$n)
  n_alleles &lt;- 2 * pop_size
  
  freqs &lt;- data.frame(
      Z = pop$n * str_count(pop$genotype, &quot;Z[+]&quot;) / n_alleles, 
      Zd = pop$n * str_count(pop$genotype, &quot;Z[*]&quot;) / n_alleles,
      Zr = pop$n * str_count(pop$genotype, &quot;Zr&quot;) / n_alleles,
      W = pop$n * str_count(pop$genotype, &quot;W[+]&quot;) / n_alleles,
      Wr = pop$n * str_count(pop$genotype, &quot;Wr&quot;) / n_alleles,
      A = pop$n * str_count(pop$genotype, &quot;A&quot;) / n_alleles,
      B = pop$n * str_count(pop$genotype, &quot;B&quot;) / n_alleles,
      females = 0, # placeholder
      N = 0
    ) %&gt;% summarise_all(sum) %&gt;% gather(allele, frequency)
  freqs$frequency[8] &lt;- (freqs$frequency[4] + freqs$frequency[5]) * 2 # females
  freqs$frequency[9] &lt;- pop_size # pop size
  freqs$frequency[1:3] &lt;- freqs$frequency[1:3] / sum(freqs$frequency[1:3]) # Z alleles
  freqs$frequency[4:5] &lt;- freqs$frequency[4:5] / sum(freqs$frequency[4:5]) # W alleles
  freqs %&gt;% mutate(frequency  = round(frequency, 3), # round to save disk space
                   generation = generation)
}</code></pre>
</div>
<div id="function-to-set-up-several-mating-type-tables" class="section level2">
<h2>Function to set up several mating type tables</h2>
<p>If running the simulation on many parameter spaces, we will first need to set up several mating_type_tables, each of which takes several seconds of compute time. To speed this up, this function identifies all the unique mating_type_tables that are implied by the table <code>parameters</code>, and generates them all in parallel using mclapply().</p>
<pre class="r"><code>set_up_mating_type_tables &lt;- function(parameters, 
                                      cores, 
                                      wd,
                                      overwrite = FALSE){
  
  path_to_tables &lt;- file.path(wd, &quot;data/mating_type_tables/&quot;)
  if(overwrite) unlink(list.files(path_to_tables, full.names = TRUE))
  
  parameters &lt;- parameters %&gt;%
    mutate(mating_table = paste(W_shredding_rate,
                                Z_conversion_rate, 
                                Zr_creation_rate,
                                Zr_mutation_rate,
                                Wr_mutation_rate, sep = &quot;_&quot;)) 
  
  uniques    &lt;- unique(parameters$mating_table)
  file.names &lt;- paste(uniques, &quot;.rds&quot;, sep = &quot;&quot;)
  uniques    &lt;- uniques[!(gsub(path_to_tables, &quot;&quot;, file.names) %in% list.files(path_to_tables))]
  
  if(length(uniques) &gt; 0){
    print(&quot;Setting up the mating type tables...&quot;)
    file.names &lt;- paste(
      path_to_tables, 
      file.names[!(file.names %in% list.files(path_to_tables))], sep = &quot;&quot;)
    
    uniques &lt;- lapply(strsplit(uniques, split = &quot;_&quot;), as.numeric)
    mclapply(1:length(uniques), function(i){
      make_mating_type_table(W_shredding_rate  = uniques[[i]][1], 
                             Z_conversion_rate = uniques[[i]][2],
                             Zr_creation_rate  = uniques[[i]][3]) %&gt;%
        add_mutants(Zr_mutation_rate = uniques[[i]][4], 
                    Wr_mutation_rate = uniques[[i]][5]) %&gt;%
        convert_probabilities() %&gt;%
        mutate(parents = paste(mother, father)) %&gt;%
        select(mother, father, parents, zygote, prop) %&gt;%
        saveRDS(file = file.names[i])
      return(NULL)
    }, mc.cores = cores)
  }
  uniques &lt;- unique(parameters$mating_table)
  
  # I added this section to fix a &quot;bug&quot;, but I think it was just an issue with the Spartan server because the bug mysteriously fixed itself!! 
  # I think this code is never actually triggered now

  files &lt;- paste(path_to_tables, uniques, &quot;.rds&quot;, sep = &quot;&quot;)
  mating_tables &lt;- vector(length(files), mode = &quot;list&quot;)
  
  for(i in 1:length(mating_tables)){
    mating_tables[[i]] &lt;- NA
    while(is.na(mating_tables[[i]])){
      try(mating_tables[[i]] &lt;- readRDS(files[[i]]))
      # if a mating table was not loadable, delete it and try again...
      if(is.na(mating_tables[[i]])){
        unlink(files[[i]])
        corrupted &lt;- as.numeric(strsplit(gsub(&quot;[.]rds&quot;, &quot;&quot;, tail(strsplit(files[[i]], split = &quot;/&quot;)[[1]], 1)), split = &quot;_&quot;)[[1]])
        
        print(&quot;A file was corrupted, deleted it and trying again...&quot;)
        print(corrupted)
        
        make_mating_type_table(W_shredding_rate  = corrupted[1], 
                               Z_conversion_rate = corrupted[2],
                               Zr_creation_rate  = corrupted[3]) %&gt;%
          add_mutants(Zr_mutation_rate = corrupted[4], 
                      Wr_mutation_rate = corrupted[5]) %&gt;%
          convert_probabilities() %&gt;%
          mutate(parents = paste(mother, father)) %&gt;%
          select(mother, father, parents, zygote, prop) %&gt;%
          saveRDS(file = files[[i]])
        print(&quot;The corrupted file has been re-made&quot;)
      }
    }
  }
  print(&quot;done them all&quot;)
  
  parameters$mating_table &lt;- (1:length(uniques))[match(parameters$mating_table, uniques)]
  print(&quot;Mating tables are all complete; ready to start&quot;)
  return(list(parameters, mating_tables))
}</code></pre>
</div>
<div id="function-to-run-the-simulation" class="section level2">
<h2>Function to run the simulation</h2>
<p>This function runs the simulation, for a single parameter space specified by <code>parameters[row, ]</code>, using a pre-made mating_type_table.</p>
<pre class="r"><code>run_simulation &lt;- function(row,
                           parameters,
                           # mating_type_table,
                           wd){
  
  output.file &lt;- sample(99999999999999, 1) # each parameter space gets a unique ID number
  set.seed(as.integer(substr(output.file, 1, 5))) # Note that the file name is also the seed
  output.file &lt;- paste(file.path(wd, &quot;data/sim_results/&quot;),
                       output.file, &quot;.rds&quot;, sep = &quot;&quot;)
  
  # Keep only the correct mating table from the list of tables made by set_up_mating_type_tables()
  # mating_type_table &lt;- mating_type_table[[parameters$mating_table[row]]]
  
  # Create the mating type table for this run (takes about 100 seconds)
  mating_type_table &lt;- make_mating_type_table(
    W_shredding_rate  = parameters$W_shredding_rate[row], 
    Z_conversion_rate = parameters$Z_conversion_rate[row],
    Zr_creation_rate  = parameters$Zr_creation_rate[row]) %&gt;%
    convert_probabilities() %&gt;%
    mutate(parents = paste(mother, father)) %&gt;%
    select(mother, father, parents, zygote, prop)
  
  # Make a table holding the quality/fitness of each genotype
  fitness_table &lt;- make_fitness_table(
    cost_Zdrive_female = parameters$cost_Zdrive_female[row],
    cost_Zdrive_male = parameters$cost_Zdrive_male[row],
    cost_Wr = parameters$cost_Wr[row],
    cost_Zr = parameters$cost_Zr[row],
    cost_A = parameters$cost_A[row],
    cost_B = parameters$cost_B[row],
    mating_type_table = mating_type_table)
  
  # Make the initial population
  pop &lt;- make_initial_population(
    initial_Zdrive = parameters$initial_Zdrive[row], 
    initial_Zr = parameters$initial_Zr[row],
    initial_Wr = parameters$initial_Wr[row],
    initial_A = parameters$initial_A[row],
    initial_B = parameters$initial_B[row],
    initial_pop_size = parameters$initial_pop_size[row],
    n_patches = parameters$n_patches[row],
    fitness_table = fitness_table)
  
  # Assign remaining parameters to variables for faster access in the while() loops
  release_size &lt;- parameters$release_size[row]
  burn_in &lt;- parameters$burn_in[row]
  softness &lt;- parameters$softness[row]
  male_weighting &lt;- parameters$male_weighting[row]
  carrying_capacity &lt;- parameters$carrying_capacity[row]
  density_dependence_shape &lt;- parameters$density_dependence_shape[row]
  male_migration_prob &lt;- parameters$male_migration_prob[row]
  female_migration_prob &lt;- parameters$female_migration_prob[row]
  migration_type &lt;- parameters$migration_type[row]
  n_patches &lt;- parameters$n_patches[row]
  max_fecundity &lt;- parameters$max_fecundity[row]
  patch_landing_probabilities &lt;- rep(1/parameters$n_patches[row], 
                                     parameters$n_patches[row])
  allele_freqs &lt;- vector(burn_in + parameters$generations[row], mode = &quot;list&quot;)
  i &lt;- 0L
  generation_extinct &lt;- NA # Declare outputs
  generation_Zd_extinct &lt;- NA
  generation_W_extinct &lt;- NA # wild-type W, aka W+
  generation_Zd_fixed &lt;- NA #If shredding rate is less than 100%, pop can sometimes persist with the Z*
  outcome &lt;- &quot;Timer expired&quot; 
  final_pop &lt;- &quot;placeholder&quot;
  
  # Do a few generations of burn-in, to allow population size and distribution to stabilise
  while(i &lt; burn_in){
    i &lt;- i + 1
    # Pick the parents, make the offspring, migrate them, then repeat
    pop &lt;- pick_mothers(pop = pop,
                 fitness_table = fitness_table,
                 n_patches = n_patches,
                 softness = softness,
                 male_weighting = male_weighting,
                 max_fecundity = max_fecundity,
                 carrying_capacity = carrying_capacity,
                 density_dependence_shape = density_dependence_shape) %&gt;%
      pick_fathers() %&gt;% 
      make_offspring(mating_type_table = mating_type_table) %&gt;%
      migrate_population(n_patches = n_patches,
                         patch_landing_probabilities = patch_landing_probabilities,
                         male_migration_prob = male_migration_prob,
                         female_migration_prob = female_migration_prob, 
                         migration_type = migration_type)
    
    # 1. Check if the pop has gone extinct,
    if(is.null(pop)){ 
      generation_extinct &lt;- NA
      outcome &lt;- &quot;Didn&#39;t survive burn-in&quot;
      final_pop &lt;- NA
      i &lt;- Inf
    } else allele_freqs[[i]] &lt;- get_allele_freqs(pop, i) # record allele freqs
         
  }
  
  # If pop survived burn-in, add Zd individuals and begin iterating over generations
  if(!is.null(pop)){
    i &lt;- 0L

    # Add the Zd individuals, AFTER calculating density-dependent fecundity 
    pop &lt;- pick_mothers(pop = pop,
                 fitness_table = fitness_table,
                 n_patches = n_patches,
                 softness = softness,
                 male_weighting = male_weighting,
                 max_fecundity = max_fecundity,
                 carrying_capacity = carrying_capacity,
                 density_dependence_shape = density_dependence_shape) %&gt;%
      release_Zd_individuals(n_patches = n_patches, 
                             fitness_table = fitness_table,
                             release_size = release_size,
                             release_strategy = parameters$release_strategy[row]) %&gt;%
      pick_fathers() %&gt;%
      make_offspring(mating_type_table = mating_type_table) %&gt;%
      migrate_population(n_patches = n_patches,
                         patch_landing_probabilities = patch_landing_probabilities,
                         male_migration_prob = male_migration_prob,
                         female_migration_prob = female_migration_prob, 
                         migration_type = migration_type)
  } else i &lt;- Inf # otherwise, skip the iterations and go to the end
  
  zero_one &lt;- c(0,1) # Declare outside the loop
  Zd_fixed_counter &lt;- 0 

  while(i &lt; parameters$generations[row]){
    i &lt;- i + 1
    # Pick the parents, make the offspring, migrate them, then repeat
    pop &lt;- pick_mothers(pop = pop,
                 fitness_table = fitness_table,
                 n_patches = n_patches,
                 softness = softness,
                 male_weighting = male_weighting,
                 max_fecundity = max_fecundity,
                 carrying_capacity = carrying_capacity,
                 density_dependence_shape = density_dependence_shape) %&gt;%
      pick_fathers() %&gt;% 
      make_offspring(mating_type_table = mating_type_table) %&gt;%
      migrate_population(n_patches = n_patches,
                         patch_landing_probabilities = patch_landing_probabilities,
                         male_migration_prob = male_migration_prob,
                         female_migration_prob = female_migration_prob, 
                         migration_type = migration_type)
    
    # 1. Check if the pop has gone extinct,
    if(is.null(pop)){ 
      generation_extinct &lt;- i
      outcome &lt;- &quot;Population extinct&quot;
      final_pop &lt;- NA
      i &lt;- Inf
    } else { 
      # 2. Check if females have gone extinct (also mark as extinct)
      if (!any(str_detect(pop$genotype, &quot;W&quot;))) { 
        generation_extinct &lt;- i
        outcome &lt;- &quot;Population extinct&quot;
        final_pop &lt;- NA
        i &lt;- Inf
      } else {
        # 3. record the allele frequencies
        i_burnin &lt;- i + burn_in
        allele_freqs[[i_burnin]] &lt;- get_allele_freqs(pop, i_burnin)

        # 4. check if driving Z has gone extinct or reached fixation,
        # or if wild-type W has been completely replaced by Wr 
        if (allele_freqs[[i_burnin]]$frequency[2] %in% zero_one | 
            allele_freqs[[i_burnin]]$frequency[4] == 0) { 
          if (allele_freqs[[i_burnin]]$frequency[2] == 0){
            generation_Zd_extinct &lt;- i_burnin
            outcome &lt;- &quot;Zd extinct&quot;
            final_pop &lt;- NA
            i &lt;- Inf
          } else if (allele_freqs[[i_burnin]]$frequency[2] == 1) { 
            if(Zd_fixed_counter == 0) generation_Zd_fixed &lt;- i
            Zd_fixed_counter &lt;- Zd_fixed_counter + 1
            if(Zd_fixed_counter == 20) { # If Zd has been fixed for 20 generations without causing a crash...
              outcome &lt;- &quot;Zd fixed without extinction&quot;
              final_pop &lt;- NA
              i &lt;- Inf
            }
          } else if (allele_freqs[[i_burnin]]$frequency[4] == 0) {   
            generation_W_extinct &lt;- i_burnin
            outcome &lt;- &quot;Wr fixed&quot;
            final_pop &lt;- NA
            i &lt;- Inf
          }
        }
      }
    } # End of &quot;If not extinct...&quot;
  } # End of while()
  if(!is.na(final_pop)) final_pop &lt;- pop
  print(outcome)
  
  list(  # return a list:               
    parameters[row, ] %&gt;% # [[1]]: A 1-row dataframe holding the parameter space and outcome
      cbind(data.frame(generation_extinct, 
                       generation_Zd_extinct, 
                       generation_W_extinct, 
                       generation_Zd_fixed,
                       outcome, 
                       stringsAsFactors = FALSE)), 
    
    allele_freqs %&gt;%      # [[2]]: The allele frequencies, for each generation
      bind_rows() %&gt;% 
      select(generation, allele, frequency),
    
    final_pop) -&gt; output         # [[3]] final population (if the generation timer ran out; otherwise NA)
    saveRDS(output, file = output.file)
    output
}</code></pre>
</div>
<div id="function-to-run-the-simulation-on-all-parameter-spaces" class="section level2">
<h2>Function to run the simulation on all parameter spaces</h2>
<p>This is a wrapper function that calls <code>run_simulation()</code> on all rows in parameters, using a specified number of CPU cores to run them in parallel using mclapply().</p>
<pre class="r"><code>do_all_parameters &lt;- function(parameters, over_write, cores, wd = NULL){
  
  if(!is.null(wd)) setwd(wd)
  else wd &lt;- getwd()
  
  # mating_type_tables &lt;- set_up_mating_type_tables(
  #   parameters, cores = cores, 
  #   overwrite = FALSE, # Change this manually if needed
  #   wd = wd) 
  # parameters &lt;- mating_type_tables[[1]] # annotate the parameters with the mating tables numbers
  # mating_type_tables &lt;- mating_type_tables[[2]] # Get the mating tables themselves
  
  
  mclapply(1:nrow(parameters), 
           function(i){
             run_simulation(
               row = i, 
               parameters = parameters,
              # mating_type_table = mating_type_tables,
               wd = wd)
           }, mc.cores = cores)
}</code></pre>
</div>
<div id="combine-all-the-results-files" class="section level2">
<h2>Combine all the results files</h2>
<pre class="r"><code>combine_results_files &lt;- function(chunk, all_files, 
                                  wd = getwd()){
  
  setwd(wd)
  print(paste(&quot;starting on&quot;, chunk, &quot;of&quot;, length(all_files)))
  vector_of_file_names &lt;- all_files[[chunk]]
  seeds &lt;- lapply(strsplit(vector_of_file_names, split = &quot;/&quot;), function(x) x[length(x)])
  
  # Get the filesnames/seeds for each of the 10,000 files in the chunk
  filenames &lt;- gsub(&quot;[.]rds&quot;, &quot;&quot;, seeds)
  
  # Open a file, or delete it if the server saved a corrupted file
  attempt_to_open &lt;- function(file){
    tryCatch(
      # 1. Try to open the RDS file
      expr = readRDS(file),
      
      # 2. If it doesn&#39;t open, delete the file and print its name, and return NA
      error = function(cond) {
        print(file)
        unlink(file)
        return(NA)})
  }
  
  # Open all 10,000 files in the chunk, and store as a list. Each element contains either a 3-element list, or NA
  list_of_lists &lt;- lapply(vector_of_file_names, attempt_to_open)

  # Only keep the elements and file names for files that opened properly
  to_keep &lt;- sapply(list_of_lists, function(x) length(x) == 3)
  filenames &lt;- filenames[to_keep]
  list_of_lists &lt;- list_of_lists[to_keep]
  rm(to_keep)

  data.frame(id = filenames,
             lapply(list_of_lists, function(x) x[[1]]) %&gt;%
               do.call(&quot;rbind&quot;, .)) %&gt;% 
  saveRDS(paste(&quot;data/results_&quot;, chunk, &quot;.rds&quot;, sep = &quot;&quot;))
  
  allele_freqs &lt;- lapply(list_of_lists, function(x) x[[2]])
  names(allele_freqs) &lt;- filenames
  saveRDS(allele_freqs, paste(&quot;data/allele_freqs_&quot;, chunk, &quot;.rds&quot;, sep = &quot;&quot;))
  
  final_pop &lt;- lapply(list_of_lists, function(x) x[[3]])
  names(final_pop) &lt;- filenames
  saveRDS(final_pop, paste(&quot;data/final_pop_&quot;, chunk, &quot;.rds&quot;, sep = &quot;&quot;))
}</code></pre>
</div>
<div id="parse-the-results-files-for-plotting" class="section level2">
<h2>Parse the results files for plotting</h2>
<div id="add_parameters" class="section level3">
<h3><code>add_parameters()</code></h3>
<p>This function takes a dataframe extracted from the big results file (<code>df</code>), and uses <code>left_join()</code> to add the parameter spaces used to generate those data. For example, one can grab a subset of the time-to-extinction results using <code>pluck(results, &quot;generation_extinct&quot;) %&gt;% filter()</code>, and then add the parameter values corresponding to each result using this function.</p>
<pre class="r"><code>add_parameters &lt;- function(df){
  df %&gt;% # Join a results table with all the variable para values
    left_join(results$parameters[, names(results$parameter) %in% 
                                   names(results$parameters %&gt;% 
                                           map(function(x) length(unique(x))))], 
              by = &quot;id&quot;)
}</code></pre>
</div>
<div id="remove_nonvariable_parameters" class="section level3">
<h3><code>remove_nonvariable_parameters()</code></h3>
<p>This function removes all columns that do not vary at all (e.g. parameters like the maximum number of generations, which was set to a single value in all simulations).</p>
<pre class="r"><code>remove_nonvariable_parameters &lt;- function(df){
  df[, apply(df, 2, function(x) length(unique(x))) &gt; 1]
}</code></pre>
</div>
<div id="pluck_allele_freqs" class="section level3">
<h3><code>pluck_allele_freqs()</code></h3>
<p>Function for grabbing the allele frequencies over time for a specific simulation run, named in the argument <code>model_id</code>.</p>
<pre class="r"><code>pluck_allele_freqs &lt;- function(model_id, allele_freqs_list){
  allele_freqs_list[as.character(model_id)][[1]]
}</code></pre>
<br>
<p>
<button type="button" class="btn btn-default btn-workflowr btn-workflowr-sessioninfo" data-toggle="collapse" data-target="#workflowr-sessioninfo" style="display: block;">
<span class="glyphicon glyphicon-wrench" aria-hidden="true"></span> Session information
</button>
</p>
<div id="workflowr-sessioninfo" class="collapse">
<pre class="r"><code>sessionInfo()</code></pre>
<pre><code>R version 3.5.1 (2018-07-02)
Platform: x86_64-apple-darwin15.6.0 (64-bit)
Running under: macOS High Sierra 10.13.6

Matrix products: default
BLAS: /Library/Frameworks/R.framework/Versions/3.5/Resources/lib/libRblas.0.dylib
LAPACK: /Library/Frameworks/R.framework/Versions/3.5/Resources/lib/libRlapack.dylib

locale:
[1] en_AU.UTF-8/en_AU.UTF-8/en_AU.UTF-8/C/en_AU.UTF-8/en_AU.UTF-8

attached base packages:
[1] parallel  stats     graphics  grDevices utils     datasets  methods  
[8] base     

other attached packages:
 [1] tibble_2.1.3   readr_1.1.1    rslurm_0.4.0   Rcpp_1.0.2    
 [5] lhs_1.0.1      reshape2_1.4.3 stringr_1.4.0  tidyr_0.8.2   
 [9] purrr_0.3.2    dplyr_0.8.3   

loaded via a namespace (and not attached):
 [1] knitr_1.23        whisker_0.3-2     magrittr_1.5     
 [4] workflowr_1.4.0   hms_0.4.2         tidyselect_0.2.5 
 [7] R6_2.4.0          rlang_0.4.0       plyr_1.8.4       
[10] tools_3.5.1       xfun_0.8          git2r_0.23.0     
[13] htmltools_0.3.6   yaml_2.2.0        rprojroot_1.3-2  
[16] digest_0.6.20     assertthat_0.2.1  crayon_1.3.4     
[19] fs_1.3.1          glue_1.3.1.9000   evaluate_0.14    
[22] rmarkdown_1.13    stringi_1.4.3     compiler_3.5.1   
[25] pillar_1.3.1.9000 backports_1.1.2   pkgconfig_2.0.2  </code></pre>
</div>
</div>
</div>


<!-- Adjust MathJax settings so that all math formulae are shown using
TeX fonts only; see
http://docs.mathjax.org/en/latest/configuration.html.  This will make
the presentation more consistent at the cost of the webpage sometimes
taking slightly longer to load. Note that this only works because the
footer is added to webpages before the MathJax javascript. -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    "HTML-CSS": { availableFonts: ["TeX"] }
  });
</script>



</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
